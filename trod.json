[
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"CodeCache 配置不合理",
        "severity":"中",
        "description":"JVM 编译优化后的代码会存储在 CodeCache 中，当 CodeCache 不足或者设置不合理时，会导致热代码退优化或重复编译，最终导致性能下降，影响业务运行",
        "verify":"检测 CodeCache 是否小于 240M，小于则告警",
        "solution":"使用默认配置或者通过 -XX:ReservedCodeCacheSize 设置合理的值，不建议小于默认值。目前 jdk8 默认值为240M，之前版本有 32M、48M 的配置，已经不适用现代的业务系统",
        "reference":["https://heapdump.cn/article/304430","https://thinkhejie.github.io/2016/05/05/JVM%E7%B3%BB%E5%88%97_06/","https://bugs.openjdk.org/browse/JDK-8051955"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"Metaspace 用量预警",
        "severity":"中",
        "description":"Metaspace 保存了 Class 元数据信息，当大小设置不足或者加载的 Class 过多时会触发 Full GC，严重影响程序性能",
        "verify":"检测 Metaspace 当前大小是否超过 MaxMetaspaceSize 参数配置的 80%，如果超过则告警",
        "solution":"当 Metaspace 大小到达 MaxMetaspaceSize 参数配置大小时，会触发 Full GC，MaxMetaspaceSize 参数设置过小可能会导致频繁 Full GC 或者 OOM，当检测到内存使用率过大时，请判断配置是否合理，一般建议配置为 512M，默认不设置则不限制大小。如果有异常占用过大情况有如下解决方案：1. 内存 dump 后分析 Class 数量，判断是否有同类型 Class 多次加载的情况。2. 启用诊断参数 -XX:+TraceClassLoading 协助判读类加载情况",
        "reference":["https://heapdump.cn/article/2152817","https://heapdump.cn/article/1700576","https://heapdump.cn/article/210111"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"OOM 时自动 Dump 配置未开启",
        "severity":"提示",
        "description":"业务系统发生 OOM 时，需尽可能自动生成 heap dump 文件。不配置相应参数，在发生 OOM 时不会自动生成 heap dump 文件，故障现场信息无法保留，为后续分析定位问题根因带来不便",
        "verify":"检测业务系统的 JVM 启动参数中是否配置 HeapDumpOnOutOfMemoryError 及 HeapDumpPath 参数，如果未配置则告警",
        "solution":"添加 JVM 参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${目录}，若是容器化部署，建议将生成路径映射到宿主机目录，避免容器自动销毁时 heap dump 文件也一并被销毁",
        "reference":["https://blog.csdn.net/a718515028/article/details/86703186","https://bbs.huaweicloud.com/blogs/330073"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"Xmx Xms 配置不一致",
        "severity":"低",
        "description":"Xms 为进程初始内存，当内存不足时会扩展最大至 Xmx 大小，当 GC 过后，可能会释放收缩内存，每一次扩展和收缩行为的发生都会与操作系统进行交互，从而影响性能",
        "verify":"检测Xmx 与 Xms 配置是否一致，如果不一致则告警",
        "solution":"为了避免频繁扩容和 GC 释放堆内存造成的系统开销/压力，建议将 Xmx，Xms 配置相同的大小",
        "reference":["https://blog.csdn.net/wo541075754/article/details/108462684","https://support.huaweicloud.com/tuningtip-kunpenggrf/kunpengtuning_12_0063.html"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"JVM 启动参数添加位置不正确",
        "severity":"提示",
        "description":"javaagent 或 agentpath 配置位置不正确，会导致 JVM 参数失效",
        "verify":"检测 javaagent 或 agentpath 参数位置是否在主启动类之前，如果不在则告警",
        "solution":"将 javaagent 或 agentpath 参数移动至主启动类之前",
        "reference":["https://blog.csdn.net/woshiyeguiren/article/details/79867320","https://heapdump.cn/article/437822"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"生成 GC 日志参数未配置",
        "severity":"提示",
        "description":"生成 GC 日志文件的启动参数未配置，将导致无法方便的查看 GC 执行详情与晋升详情，不利于出现问题时的排查定位",
        "verify":"检测 PrintGCDetails、PrintGCDateStamps、Xloggc 参数是否配置，如果未配置则告警",
        "solution":"JDK8下可设置必备参数，打印基本信息： -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:${path}/gc.log 可选参数，用于分析SWT信息： -XX:+PrintGCApplicationStoppedTime -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1",
        "reference":["https://segmentfault.com/a/1190000039806436"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"DisableExplicitGC 配置未关闭",
        "severity":"低",
        "description":"三方框架中可能存在主动调用 System.gc 以便 DirectMemory 不够时可以主动回收直接内存，如果禁用掉就会导致堆外内存使用一直增长，最终可能造成内存泄露。",
        "verify":"检测 DisableExplicitGC 参数是否配置，如果配置则告警",
        "solution":"建议保持默认配置不启用 DisableExplicitGC，不干扰 System.gc 的行为，如果发现 GC 日志中存在比较多的 Full GC 并且 GC 触发原因是 System.gc，则建议排查业务代码中是否存在主动调用的情况",
        "reference":["https://blog.csdn.net/bingxuesiyang/article/details/105527220"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JVM",
        "risk":"配置了失效的 JVM 参数",
        "severity":"提示",
        "description":"已失效的参数设置可能会造成误解，以为已经设置了相关参数的，例如 jdk8 中使用了失效的 PermSize 和 MaxPermSize",
        "verify":"检测 PermSize、MaxPermSize 等失效参数是否配置，如果配置则告警",
        "solution":"建议移除已失效的 JVM 参数",
        "reference":["https://blog.csdn.net/f80407515/article/details/116858289"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JDK",
        "risk":"ConcurrentHashMap computeIfAbsent 递归调用导致死循环",
        "severity":"中",
        "description":"如 JDK-8062841 BUG描述，递归调用 ConcurrentHashMap.computeIfAbsent 会造成线程 CPU 使用率100%问题",
        "verify":"检测 JDK 版本，如果是 8 则告警",
        "solution":"避免使用递归的方式创建 ConcurrentHashMap 对象或将 JDK 版本升级到 9",
        "reference":["https://heapdump.cn/article/2061109","https://blog.csdn.net/weixin_42083242/article/details/85223512","https://www.jianshu.com/p/59bd27e137e1","https://bugs.openjdk.org/browse/JDK-8062841"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"虚拟机",
        "stack":"JDK",
        "risk":"HttpURLConnection setFixedLengthStreamingMode 性能问题",
        "severity":"中",
        "description":"如 JDK-8072586 BUG描述，当使用HttpURLConnection.setFixedLengthStreamingMode 设置 fixedContentLength 属性后，getOutputStream() 获取请求返回流性能相比 JDK 7u25 下降了6倍",
        "verify":"检测 JDK 版本，如果是 7u40及以上版本 则告警",
        "solution":"在该问题被Fix之前，先避免使用 setFixedLengthStreamingMode 方式，可以多使用 setChunkedStreamingMode 替代",
        "reference":["https://bugs.openjdk.org/browse/JDK-8072586","https://github.com/jimma/jdk7u40-httpurlconnection-issue"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"操作系统",
        "stack":"系统配置",
        "risk":"服务器端口可用范围过小",
        "severity":"提示",
        "description":"系统端口范围配置不足时,在瞬时短连接过多情况下可能导致客户端请求服务端出现java.net.NoRouteToHostException: Cannot assign requested address错误，无可用端口号,导致无法和服务端建立连接",
        "verify":"检测系统端口配置情况，如果可用端口号范围 < 20000 则告警",
        "solution":"可根据实际情况更改服务器端口可用范围：类似如下命令 echo '15000 64000' > /proc/sys/net/ipv4/ip_local_port_range",
        "reference":["https://www.cnblogs.com/solohac/p/4154180.html","https://blog.csdn.net/ichen820/article/details/105687422"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"操作系统",
        "stack":"系统配置",
        "risk":"未开启 core dump 配置",
        "severity":"提示",
        "description":"未开启 core dump 配置，会导致无法保留完整的内存信息，不利于后续故障定位",
        "verify":"使用 ulimit -c 查看 core dump 是否打开，如果为 0 则告警",
        "solution":"建议打开可通过ulimit -a查看core file size大小，通过ulimit -c设置合理数值或者unlimited。（提示：core dump文件会占用较大的硬盘容量，请及时清理）",
        "reference":["https://blog.csdn.net/wjc19911118/article/details/105253055","https://www.cnblogs.com/byeyear/p/10500054.html"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"操作系统",
        "stack":"系统配置",
        "risk":"不应开启 swap 空间配置",
        "severity":"提示",
        "description":"当系统内存不足时，会触发内核将一部分进程的内存 swap 到磁盘，如果 java 进程的内存被 swap 出去，会导致该进程 GC 扫描时间变长，从而影响系统性能",
        "verify":"判断 swap 开启状态，如果开启，则告警",
        "solution":"建议关闭 swap 空间，提高系统整体性能",
        "reference":["https://heapdump.cn/article/2493856","https://wsgzao.github.io/post/swap/"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"com.alibaba.druid",
        "risk":"removeAbandoned logAbandoned 开启后会触发爬栈",
        "severity":"中",
        "description":"removeAbandoned（当removeAbandoned=true之后，可以在内置监控界面datasource.html中的查看ActiveConnection StackTrace属性的，可以看到未关闭连接的具体堆栈信息，从而方便查出哪些连接泄漏了）、logAbandoned（当druid强制回收连接后，是否将stack trace 记录到日志中）这两项配置会触发爬栈和更多的日志输出从而影响性能，都不建议在生产环境开启",
        "verify":"判断 removeAbandoned logAbandoned 是否为 true，是则告警",
        "solution":"设置 removeAbandoned=false，logAbandoned=false",
        "reference":["https://github.com/alibaba/druid/wiki/%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F%E7%9B%91%E6%B5%8B"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"com.alibaba.druid",
        "risk":"testOnBorrow testOnReturn 开启后导致性能骤降",
        "severity":"中",
        "description":"testOnBorrow testOnReturn 开启后，都会执行 validationQuery 检测连接是否有效。testOnBorrow 和 testOnReturn 在生产环境一般是不开启的，主要是性能考虑。如果考虑失效连接的处理，可以通过 testWhileIdle 来保障，如果获取到了不可用的数据库连接，一般由应用处理异常。",
        "verify":"判断 testOnBorrow testOnReturn 是否为 true，是则告警",
        "solution":"设置 testOnBorrow=false，testOnReturn=false",
        "reference":["https://heapdump.cn/article/1675496","https://mysql-rtdocs.readthedocs.io/en/latest/%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/connection%E5%A4%B1%E6%95%88-testOnBorrow/"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"com.alibaba.druid",
        "risk":"initialSize minIdle 未配置",
        "severity":"低",
        "description":"当项目第一次进行增，删，改，查的时候，连接池会初始化，这个时候会根据 initialSize 参数初始化数据库连接放入连接池中，如果未配置或配置为0，则无法正常运行；minIdle 用于指定连接池中的最小空闲连接数，设置这个参数可以应对突发流量，如果没有设置空闲连接，当有多个请求同时调用数据库，但是连接池中并没有可用连接，这时就必须创建连接，创建连接是一个非常耗时的操作，有可能会导致请求超时。",
        "verify":"判断 initialSize minIdle 是否为 0，是则告警",
        "solution":"根据实际情况，配置一个合理的数值",
        "reference":["https://www.jianshu.com/p/f2d24a6ca146","https://blog.csdn.net/zzy7075/article/details/121633424"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"ch.qos.logback",
        "risk":"未开启 AsyncAppender 异步写日志模式",
        "severity":"中",
        "description":"当系统日志较多或写入性能较差可能会阻塞业务代码的运行，配置日志异步写可以提高写入效率，减少对业务的影响",
        "verify":"判断是否配置 ch.qos.logback.classic.AsyncAppender，未配置则告警",
        "solution":"配置 logback appender class 为 ch.qos.logback.classic.AsyncAppender",
        "reference":["https://www.jianshu.com/p/cc4253ed721f","https://leokongwq.github.io/2019/12/14/logback-best-practise.html","https://www.cnblogs.com/duanxz/p/3461832.html","https://heapdump.cn/article/1828318"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"ch.qos.logback",
        "risk":"pattern 配置不合理导致爬栈",
        "severity":"中",
        "description":"日志框架对堆栈信息的存在并发控制，并且比较消耗性能，当 log4j 或 logback 等日志组件的 pattern 中配置了文件名、类名、方法名、行号的时候，会导致爬栈操作，严重影响性能",
        "verify":"判断 ch.qos.logback.classic.Logger pattern() 中是否包含文件名、类名、方法名、行号等会导致爬栈的参数，同时判断 ch.qos.logback.classic.AsyncAppender.includeCallerData 是否为 true，如果是则告警",
        "solution":"建议移除以下会导致爬栈的参数：Logback && Log4j 相关配置：%F %file 打印文件名；%C %class 打印类名；%M %method 打印方法名；%L %line 打印代码行号；AsyncAppender的includeCallerData=true；Log4j配置：%l %location 打印location",
        "reference":["https://heapdump.cn/article/2699465"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"ch.qos.logback",
        "risk":"开启 packagingData 导致频繁类加载",
        "severity":"中",
        "description":"packagingData 参数是在栈信息的基础上，额外增加了 jar 包的名称和版本信息，该配置参数虽然有用，但是十分昂贵，每个类都会触发类加载操作",
        "verify":"判断 LoggerContext 的 packagingDataEnabled 属性 是否为 true，如果是则告警",
        "solution":"建议在生产环境关闭 packagingData",
        "reference":["https://heapdump.cn/article/3876464"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"中间件",
        "stack":"ch.qos.logback",
        "risk":"discardingThreshold 配置为0导致线程阻塞",
        "severity":"中",
        "description":"当队列的剩余容量小于 discardingThreshold 阈值并且当前日志 level 为 TRACE, DEBUG, INFO时，则丢弃这些日志，而当 discardingThreshold 为 0 时，则不会丢弃 TRACE, DEBUG or INFO level的日志。尤其是日志级别为 debug 时，日志量很大，如果磁盘 IO 性能不高，异步日志线程将来不及输出，队列排满，业务线程又不能丢弃日志，就会导致阻塞",
        "verify":"判断 discardingThreshold 属性配置是否为 0，如果是则告警",
        "solution":"1.discardingThreshold 设置大于 0 的值，当队列满时允许丢弃TRACE, DEBUG, INFO级别的日志；2.配合设置 neverBlock 为 true，如果队列满则直接返回，而不是被挂起当前线程；",
        "reference":["https://heapdump.cn/article/2690748","https://www.sohu.com/a/207100497_100013542"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"Java应用",
        "stack":"并发场景",
        "risk":"HashMap 多线程并发死循环",
        "severity":"中",
        "description":"在并发的情况下发生扩容时，可能会产生循环链表，在执行 Hash.get 方法的时候，会触发死循环，导致 CPU 100%",
        "verify":"检测是否有线程占用了较高的 CPU 且线程栈顶运行的是否为 Hash.get 函数，如果是则告警",
        "solution":"并发场景建议使用 ConcurrentHashMap 代替 HashMap 或者一定要使用时可以添加并发控制",
        "reference":["https://juejin.cn/post/6844903554264596487"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"Java应用",
        "stack":"并发场景",
        "risk":"线程阻塞",
        "severity":"高",
        "description":"严重的线程阻塞，会对系统响应时间和TPS造成巨大影响",
        "verify":"判断状态为 Block、Waiting、Timed_Waiting 等非空闲等锁线程数（或比例）是否达到预警阈值，如果是则告警",
        "solution":"建议根据扫描结果，进一步判断对应的线程是否存在资源竞争",
        "reference":["https://blog.csdn.net/weixin_41101173/article/details/79679300","https://heapdump.cn/article/2697019"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"Java应用",
        "stack":"网络",
        "risk":"getHostName getLocalHost 性能缓慢",
        "severity":"高",
        "description":"根据 javadocs 对 InetAddress#getHostName() 的介绍，调用此方法将执行反向主机名查找。 因此，该方法调用的性能取决于 JVM 和目标主机的域名服务器之间的网络及技术栈的性能。当配置的 DNS 服务器与目标 InetAddress 之间网络状况不佳就会产生巨大的延时",
        "verify":"判断 java.net.InetAddress.getHostName() 及 getLocalHost() 两个方法的调用是否传入参数，如果未传入则告警",
        "solution":"修改 /etc/hosts，配置要查询匹配的域名、IP",
        "reference":["http://chenmutian.com/2019/04/23/inetadress-slowly/"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"操作系统",
        "stack":"网络",
        "risk":"tcp_tw_recycle tcp_timestamps 同时开启导致连接被拒绝",
        "severity":"高",
        "description":"服务器配置 tcp_timestamps == 1 && tcp_tw_recycle == 1 的情况下，会导致在 NAT 情况下被动拒绝连接的问题；对于服务端来说，同一个 SRC IP，可能会是 NAT 后面的很多机器，这些机器的 timestamp 递增性无法保证，服务器会拒绝非递增请求连接；",
        "verify":"判断 tcp_tw_recycle 以及 tcp_timestamps 值是否都为 1，如果是则告警",
        "solution":"将 tcp_tw_recycle 设置为 0 或者将 tcp_timestamps 设置为 0",
        "reference":["https://heapdump.cn/article/2322738","https://blog.csdn.net/cheng_fangang/article/details/52127642"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    },
    {
        "field":"操作系统",
        "stack":"网络",
        "risk":"nf_conntrack_max 配置不合理导致网络丢包",
        "severity":"高",
        "description":"如果 nf_conntrack_max 配置太小，TCP 连接很快就被塞满，一旦塞满了就会随机的 drop 包。就会出现  nf_conntrack: table full, dropping packet. 报错，表现为该服务器网络丢包情况非常厉害。",
        "verify":"判断 nf_conntrack_max 和 nf_conntrack_buckets 两个配置的值是否符合官方推荐的优化值，如果不符合则告警",
        "solution":"按官方给到的 nf_conntrack_max 公式进行优化配置并更新到 /etc/sysctl.conf；nf_conntrack_max 官方推荐值：nf_conntrack_max = RAMSIZE (in bytes) / 16384 / (ARCH / 32) ；nf_conntrack_buckets 官方推荐值：nf_conntrack_buckets = nf_conntrack_max/4；ARCH 指的是机器 CPU 的架构，取值范围是：64 或 32；RAMSIZE 为机器内存大小",
        "reference":["https://jusene.github.io/2020/10/29/conntrack/","http://www.yangxg.com/blog/id/1555415760"],
        "committer":"HeapDump性能社区",
        "contact":"https://heapdump.cn"
    }
]
